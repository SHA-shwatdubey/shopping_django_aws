name: Deploy Django App and Monitoring to AWS

on:
  push:
    branches:
      - main
  workflow_dispatch:  # Allow manual trigger

env:
  AWS_REGION: ap-south-1
  TERRAFORM_VERSION: 1.6.0

jobs:
  terraform:
    name: Terraform Plan & Apply (Django + Monitoring)
    runs-on: ubuntu-latest
    outputs:
      instance_ip: ${{ steps.terraform-output.outputs.instance_ip }}
      instance_id: ${{ steps.terraform-output.outputs.instance_id }}
      nagios_ip: ${{ steps.terraform-output.outputs.nagios_ip }}
      nagios_id: ${{ steps.terraform-output.outputs.nagios_id }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v2
        with:
          terraform_version: ${{ env.TERRAFORM_VERSION }}

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup SSH Keys
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.EC2_SSH_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          ssh-keygen -y -f ~/.ssh/id_rsa > ~/.ssh/id_rsa.pub
          cat ~/.ssh/id_rsa.pub

      - name: Create terraform.tfvars
        run: |
          cat > terraform.tfvars <<EOF
          aws_region      = "ap-south-1"
          project_name    = "shoppinglyx"
          environment     = "dev"
          instance_type   = "t3.micro"
          root_volume_size = 20
          nagios_instance_type = "t3.small"
          nagios_root_volume_size = 20
          public_key_path = "$HOME/.ssh/id_rsa.pub"
          allowed_ssh_cidr = ["0.0.0.0/0"]
          use_elastic_ip = false
          nagios_admin_password = "${{ secrets.NAGIOS_ADMIN_PASSWORD }}"
          nagios_email_alerts = "${{ secrets.NAGIOS_EMAIL_ALERTS }}"
          slack_webhook_url = "${{ secrets.SLACK_WEBHOOK_URL }}"
          enable_nagios_monitoring = true
          EOF
          cat terraform.tfvars
        working-directory: ./terraform

      - name: Terraform Format Check
        run: terraform fmt -check -recursive
        working-directory: ./terraform
        continue-on-error: true

      - name: Cleanup AWS Resources (Key Pairs & Security Groups)
        run: |
          echo "Cleaning up orphaned AWS resources from previous deployments..."
          
          # Delete all shoppinglyx key pairs with retries
          aws ec2 describe-key-pairs --region ap-south-1 --query 'KeyPairs[?starts_with(KeyName, `shoppinglyx`)].KeyName' --output text | while read key; do
            if [ ! -z "$key" ]; then
              echo "Deleting key pair: $key"
              for i in {1..3}; do
                aws ec2 delete-key-pair --key-name "$key" --region ap-south-1 2>/dev/null && echo "‚úì Deleted: $key" && break || echo "Retry $i/3..."
                sleep 2
              done
            fi
          done
          
          # Wait for key pairs to be fully deleted
          sleep 10
          
          # Delete all shoppinglyx security groups (except default) - try multiple times
          for attempt in {1..5}; do
            echo "Security group deletion attempt $attempt/5..."
            deleted_any=0
            aws ec2 describe-security-groups --region ap-south-1 --filters "Name=group-name,Values=shoppinglyx-*" --query 'SecurityGroups[*].[GroupId,GroupName]' --output text | while read sg_id sg_name; do
              if [ ! -z "$sg_id" ] && [ "$sg_id" != "None" ]; then
                echo "Deleting security group: $sg_id ($sg_name)"
                aws ec2 delete-security-group --group-id "$sg_id" --region ap-south-1 2>/dev/null && echo "‚úì Deleted: $sg_id" && deleted_any=1 || echo "‚úó Failed: $sg_id (may have dependencies)"
              fi
            done
            sleep 5
          done
          
          echo "Cleanup completed"
        env:
          AWS_REGION: ap-south-1
        continue-on-error: true

      - name: Terraform Init (for cleanup)
        run: terraform init
        working-directory: ./terraform
        continue-on-error: true

      - name: Terraform Destroy Previous Resources
        run: terraform destroy -auto-approve -var-file=terraform.tfvars || true
        working-directory: ./terraform
        continue-on-error: true

      - name: Clean Terraform State (Remove conflicting resources)
        run: |
          # Backup old state
          cp terraform.tfstate terraform.tfstate.backup || true
          
          # Remove ALL state resources that might conflict
          terraform state list 2>/dev/null | while read resource; do
            case "$resource" in
              aws_key_pair*|aws_security_group*|aws_security_group_rule*)
                terraform state rm "$resource" || true
                ;;
            esac
          done
          
          echo "Terraform state cleaned"
        working-directory: ./terraform
        continue-on-error: true

      - name: Terraform Init
        run: terraform init
        working-directory: ./terraform

      - name: Terraform Plan
        run: terraform plan -out=tfplan -var-file=terraform.tfvars
        working-directory: ./terraform

      - name: Terraform Apply
        run: terraform apply -auto-approve tfplan
        working-directory: ./terraform

      - name: Extract Terraform Outputs
        id: terraform-output
        run: |
          cd terraform
          
          # Get Django app outputs
          raw_instance_ip=$(terraform output -raw instance_public_ip 2>/dev/null | grep -oE '[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}' | head -1 || true)
          raw_instance_id=$(terraform output -raw instance_id 2>/dev/null | grep -oE '^i-[a-f0-9]{17}' | head -1 || true)
          
          # Get Nagios server outputs
          raw_nagios_ip=$(terraform output -raw nagios_server_public_ip 2>/dev/null | grep -oE '[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}' | head -1 || true)
          raw_nagios_id=$(terraform output -raw nagios_server_instance_id 2>/dev/null | grep -oE '^i-[a-f0-9]{17}' | head -1 || true)

          instance_ip="${raw_instance_ip:-10.0.1.0}"
          instance_id="${raw_instance_id:-i-0000000000000000}"
          nagios_ip="${raw_nagios_ip:-10.0.2.0}"
          nagios_id="${raw_nagios_id:-i-0000000000000001}"
          
          {
            echo "instance_ip<<EOF"
            echo "$instance_ip"
            echo "EOF"
            echo "instance_id<<EOF"
            echo "$instance_id"
            echo "EOF"
            echo "nagios_ip<<EOF"
            echo "$nagios_ip"
            echo "EOF"
            echo "nagios_id<<EOF"
            echo "$nagios_id"
            echo "EOF"
          } >> $GITHUB_OUTPUT
          
          echo "=== Terraform Outputs ==="
          echo "Django Instance IP: $instance_ip"
          echo "Django Instance ID: $instance_id"
          echo "Nagios Server IP: $nagios_ip"
          echo "Nagios Server ID: $nagios_id"

  deploy-application:
    name: Deploy Django Application
    needs: terraform
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Python for Ansible
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'
          cache: 'pip'

      - name: Install Ansible
        run: |
          pip install --upgrade pip
          pip install ansible>=2.10 boto3 botocore

      - name: Create SSH key
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.EC2_SSH_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          ssh-keyscan -H ${{ needs.terraform.outputs.instance_ip }} >> ~/.ssh/known_hosts 2>/dev/null || true

      - name: Create Ansible inventory
        run: |
          INSTANCE_IP="${{ needs.terraform.outputs.instance_ip }}"
          INSTANCE_IP=$(echo "$INSTANCE_IP" | tr -d ' "')
          
          cat > ansible/inventory.ini <<INVENTORY
          [django_servers]
          django_server ansible_host=$INSTANCE_IP ansible_user=ubuntu
          
          [django_servers:vars]
          ansible_python_interpreter=/usr/bin/python3
          django_repo_url=https://github.com/${{ github.repository }}.git
          django_secret_key=${{ secrets.DJANGO_SECRET_KEY }}
          INVENTORY

      - name: Wait for Django EC2 instance
        run: |
          for i in {1..30}; do
            if ssh -o StrictHostKeyChecking=no -o ConnectTimeout=5 ubuntu@${{ needs.terraform.outputs.instance_ip }} "echo ready"; then
              echo "Instance is ready!"
              break
            fi
            echo "Attempt $i/30: Waiting..."
            sleep 10
          done

      - name: Run Django deployment playbook
        run: |
          ansible-playbook \
            -i ansible/inventory.ini \
            -u ubuntu \
            --private-key ~/.ssh/id_rsa \
            -v \
            ansible/site.yml
        env:
          ANSIBLE_HOST_KEY_CHECKING: 'False'

  deploy-monitoring:
    name: Deploy Nagios Monitoring
    needs: terraform
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Python for Ansible
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'
          cache: 'pip'

      - name: Install Ansible
        run: |
          pip install --upgrade pip
          pip install ansible>=2.10 boto3 botocore

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ap-south-1

      - name: Create SSH keys
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.EC2_SSH_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          ssh-keyscan -H ${{ needs.terraform.outputs.nagios_ip }} >> ~/.ssh/known_hosts 2>/dev/null || true
          ssh-keyscan -H ${{ needs.terraform.outputs.instance_ip }} >> ~/.ssh/known_hosts 2>/dev/null || true

      - name: Create Nagios inventory
        run: |
          NAGIOS_IP="${{ needs.terraform.outputs.nagios_ip }}"
          DJANGO_IP="${{ needs.terraform.outputs.instance_ip }}"
          DJANGO_PRIVATE_IP=$(aws ec2 describe-instances \
            --instance-ids ${{ needs.terraform.outputs.instance_id }} \
            --region ap-south-1 \
            --query 'Reservations[0].Instances[0].PrivateIpAddress' \
            --output text)
          NAGIOS_PRIVATE_IP=$(aws ec2 describe-instances \
            --instance-ids ${{ needs.terraform.outputs.nagios_id }} \
            --region ap-south-1 \
            --query 'Reservations[0].Instances[0].PrivateIpAddress' \
            --output text)
          
          NAGIOS_IP=$(echo "$NAGIOS_IP" | tr -d ' "')
          DJANGO_IP=$(echo "$DJANGO_IP" | tr -d ' "')
          
          cat > ansible/monitoring_inventory.ini <<INVENTORY
          [nagios_servers]
          nagios_server ansible_host=$NAGIOS_IP ansible_user=ubuntu ansible_ssh_private_key_file=~/.ssh/id_rsa
          
          [django_servers]
          django_app ansible_host=$DJANGO_IP ansible_user=ubuntu ansible_ssh_private_key_file=~/.ssh/id_rsa
          
          [monitoring:children]
          nagios_servers
          django_servers
          
          [monitoring:vars]
          ansible_python_interpreter=/usr/bin/python3
          nagios_admin_username=nagiosadmin
          nagios_admin_password=${{ secrets.NAGIOS_ADMIN_PASSWORD }}
          nagios_email_alerts=${{ secrets.NAGIOS_EMAIL_ALERTS }}
          django_app_private_ip=$DJANGO_PRIVATE_IP
          nagios_server_private_ip=$NAGIOS_PRIVATE_IP
          INVENTORY

      - name: Wait for Nagios EC2 instance
        run: |
          echo "Waiting for Nagios instance at ${{ needs.terraform.outputs.nagios_ip }}"
          for i in {1..60}; do
            if ssh -o StrictHostKeyChecking=no -o ConnectTimeout=10 -o UserKnownHostsFile=/dev/null ubuntu@${{ needs.terraform.outputs.nagios_ip }} "echo ready" 2>/dev/null; then
              echo "‚úÖ Nagios instance is ready!"
              break
            fi
            echo "Attempt $i/60: Waiting... (retry in 5s)"
            sleep 5
            if [ $i -eq 60 ]; then
              echo "‚ùå Nagios instance failed to respond after 300 seconds"
              exit 1
            fi
          done

      - name: Wait for Django EC2 instance
        run: |
          echo "Waiting for Django instance at ${{ needs.terraform.outputs.instance_ip }}"
          for i in {1..60}; do
            if ssh -o StrictHostKeyChecking=no -o ConnectTimeout=10 -o UserKnownHostsFile=/dev/null ubuntu@${{ needs.terraform.outputs.instance_ip }} "echo ready" 2>/dev/null; then
              echo "‚úÖ Django instance is ready!"
              break
            fi
            echo "Attempt $i/60: Waiting... (retry in 5s)"
            sleep 5
            if [ $i -eq 60 ]; then
              echo "‚ùå Django instance failed to respond after 300 seconds"
              exit 1
            fi
          done

      - name: Display Nagios inventory
        run: |
          echo "=== Nagios Ansible Inventory ==="
          cat ansible/monitoring_inventory.ini
          echo "==== End Inventory ===="

      - name: Run Nagios deployment playbook
        run: |
          ansible-playbook \
            -i ansible/monitoring_inventory.ini \
            -u ubuntu \
            --private-key ~/.ssh/id_rsa \
            -vvv \
            ansible/deploy_monitoring.yml
        env:
          ANSIBLE_HOST_KEY_CHECKING: 'False'

  notify:
    name: Send Deployment Notifications
    needs: [terraform, deploy-application, deploy-monitoring]
    runs-on: ubuntu-latest
    if: always()
    
    steps:
      - name: Check deployment status
        run: |
          if [ "${{ needs.terraform.result }}" == "success" ] && \
             [ "${{ needs.deploy-application.result }}" == "success" ] && \
             [ "${{ needs.deploy-monitoring.result }}" == "success" ]; then
            echo "‚úÖ All deployments completed successfully!"
          else
            echo "‚ùå Some deployments failed!"
            exit 1
          fi

      - name: Send Slack notification
        if: ${{ secrets.SLACK_WEBHOOK_URL }}
        run: |
          curl -X POST -H 'Content-type: application/json' \
            --data '{
              "text": "üöÄ Django & Nagios Deployment Complete",
              "blocks": [
                {
                  "type": "section",
                  "text": {
                    "type": "mrkdwn",
                    "text": "‚úÖ *Deployment Successful*\n\n*Django App:* http://${{ needs.terraform.outputs.instance_ip }}\n*Nagios Dashboard:* http://${{ needs.terraform.outputs.nagios_ip }}/nagios\n*Repository:* ${{ github.repository }}\n*Commit:* ${{ github.sha }}"
                  }
                }
              ]
            }' \
            ${{ secrets.SLACK_WEBHOOK_URL }}

      - name: Display deployment information
        run: |
          echo "=========================================="
          echo "‚úÖ DEPLOYMENT COMPLETED SUCCESSFULLY"
          echo "=========================================="
          echo ""
          echo "Django Application:"
          echo "  URL: http://${{ needs.terraform.outputs.instance_ip }}"
          echo "  SSH: ssh -i ~/.ssh/id_rsa ubuntu@${{ needs.terraform.outputs.instance_ip }}"
          echo ""
          echo "Nagios Monitoring:"
          echo "  Dashboard: http://${{ needs.terraform.outputs.nagios_ip }}/nagios"
          echo "  Username: nagiosadmin"
          echo "  SSH: ssh -i ~/.ssh/id_rsa ubuntu@${{ needs.terraform.outputs.nagios_ip }}"
          echo ""
          echo "=========================================="
