---
- name: Ensure application directory exists
  file:
    path: "{{ app_directory }}"
    state: directory
    owner: "{{ app_user }}"
    group: "{{ app_group }}"
    mode: '0755'

- name: Clone or update Django repository
  git:
    repo: "{{ repo_url }}"
    dest: "{{ app_directory }}"
    version: "{{ repo_branch }}"
    force: yes
  become_user: "{{ app_user }}"

- name: List cloned directory contents
  command: "find {{ app_directory }} -maxdepth 3 -type f -name '*.py' | grep -E '(manage|settings)' | head -20"
  register: python_files
  changed_when: false
  ignore_errors: yes

- name: Show found Python files
  debug:
    var: python_files.stdout_lines

- name: Check for manage.py location
  command: "find {{ app_directory }} -type f -name 'manage.py'"
  register: manage_py_location
  changed_when: false
  ignore_errors: yes

- name: Show manage.py path
  debug:
    var: manage_py_location.stdout_lines

- name: Determine actual Django app location
  shell: |
    # Check if manage.py exists in app_directory
    if [ -f "{{ app_directory }}/manage.py" ]; then
      echo "{{ app_directory }}"
      exit 0
    fi
    
    # Check if it's in django_project/ subdirectory
    if [ -f "{{ app_directory }}/django_project/manage.py" ]; then
      echo "{{ app_directory }}/django_project"
      exit 0
    fi
    
    # Check if it's in shoppinglyx/ subdirectory
    if [ -f "{{ app_directory }}/shoppinglyx/manage.py" ]; then
      echo "{{ app_directory }}/shoppinglyx"
      exit 0
    fi
    
    # Search for manage.py
    FOUND=$(find {{ app_directory }} -maxdepth 2 -name 'manage.py' -type f | head -1)
    if [ -n "$FOUND" ]; then
      dirname "$FOUND"
    else
      echo "{{ app_directory }}"
    fi
  register: actual_app_dir
  changed_when: false

- name: Set actual Django app directory
  set_fact:
    django_app_dir: "{{ actual_app_dir.stdout }}"

- name: Show detected Django app directory
  debug:
    msg: "Django app directory: {{ django_app_dir }}"

- name: Create Python virtual environment
  command: "python3.11 -m venv {{ venv_directory }}"
  args:
    creates: "{{ venv_directory }}/bin/activate"
  become_user: "{{ app_user }}"

- name: Upgrade pip in virtual environment
  pip:
    name:
      - pip
      - setuptools
      - wheel
    state: latest
    virtualenv: "{{ venv_directory }}"
    virtualenv_command: "python3.11 -m venv"

- name: Install Django and dependencies
  pip:
    name:
      - Django>=4.0
      - gunicorn
      - psycopg2-binary
      - python-decouple
    virtualenv: "{{ venv_directory }}"
    virtualenv_command: "python3.11 -m venv"
  become_user: "{{ app_user }}"

- name: Check if requirements.txt exists in app directory
  stat:
    path: "{{ django_app_dir }}/requirements.txt"
  register: requirements_check

- name: Install requirements.txt if it exists
  pip:
    requirements: "{{ django_app_dir }}/requirements.txt"
    virtualenv: "{{ venv_directory }}"
    virtualenv_command: "python3.11 -m venv"
  when: requirements_check.stat.exists
  ignore_errors: yes
  become_user: "{{ app_user }}"

- name: Create .env file for Django settings
  template:
    src: django_env.j2
    dest: "{{ django_app_dir }}/.env"
    owner: "{{ app_user }}"
    group: "{{ app_group }}"
    mode: '0600'

- name: Run Django migrations
  shell: |
    bash -c "source {{ venv_directory }}/bin/activate && cd {{ django_app_dir }} && python manage.py migrate --noinput || true"
  args:
    executable: /bin/bash
  become_user: "{{ app_user }}"
  environment:
    DJANGO_SETTINGS_MODULE: "shoppinglyx.settings"
    PATH: "{{ venv_directory }}/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin"
  ignore_errors: yes

- name: Collect static files
  shell: |
    bash -c "source {{ venv_directory }}/bin/activate && cd {{ django_app_dir }} && python manage.py collectstatic --noinput || true"
  args:
    executable: /bin/bash
  become_user: "{{ app_user }}"
  environment:
    DJANGO_SETTINGS_MODULE: "shoppinglyx.settings"
    PATH: "{{ venv_directory }}/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin"
  ignore_errors: yes
